#include <stdio.h>
#include <stdlib.h>
/*
浮点数的内存被分成了三个部分，分别用来存储符号位、尾数、指数。
1.符号的存储：用 0 表示正数，用 1 表示负数。
2.尾数的存储：因为采用二进制，尾数的部分 1<=尾数<2，尾数的部分必定是1，恒定值。对于1.0011101，就是把0011101放入内存。节省一个bit的内存。
3.指数的存储: 指数是一个整数，并且正负之分，不但需要存储他的值，还能区分他的正负号。
float的指数部分占为8bit,能表示0-255的值,指数在写入内存前加127，读取时再减去127，正数负数就显而易见。
即先确定内存中，指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值。这样符号和值全都确认下来了。

精度问题:
对于十进制小数，整数部分通过 不断除以2，直到余数为0。一个有限位数的整数一定能转换为有限位数的二进制。
但是小数就不一定了，小数部分转换为二进制使用"乘2取整法"，不断乘以2，直到小数部分为0。一个有限位数的小数并不一定能转换成有限位数的 二进制。
对于float，尾数部分有23位，再加上一个隐含的整数1，一共是24位。最后一位可能是精确数字，也可能是近似数字； 除此之外剩余的23位一定是精确数字。从二进制角度看，整体精度在23-24位之间。从十进制的角度来看整体精度是7-8位。
同理 double二进制精度为52-53位，十进制形式的精度为15-16位。
*/



//浮点数结构体
typedef struct {
    unsigned int nMant : 23;  //尾数部分
    unsigned int nExp : 8;  //指数部分
    unsigned int nSign : 1;  //符号位
} FP_SINGLE;

int main()
{
    char strBin[33] = { 0 };
    float f = 19.625;
    FP_SINGLE *p = (FP_SINGLE*)&f;
   
    printf("sign: %X\n", p->nSign); //sign: 0
    printf("exp: %X\n", p->nExp);   //exp: 83
    printf("mant: %X\n", p->nMant); //mant: 1D0000
   
    /**
    *精度损失问题，因为128.101转换为浮点格式后尾数部分过长，被丢掉了，不能被真实的存储。
    */
    
    float a = 128.101;
    printf("a : %f\n", a); //128.100998
    return 0;
}
