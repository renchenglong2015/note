#include <stdio.h>
#include <stdlib.h>
/*
浮点数的内存被分成了三个部分，分别用来存储符号位、尾数、指数。
1.符号的存储：用 0 表示正数，用 1 表示负数。
2.尾数的存储：因为采用二进制，尾数的部分 1<=尾数<2，尾数的部分必定是1，恒定值。对于1.0011101，就是把0011101放入内存。节省一个bit的内存。
3.指数的存储: 指数是一个整数，并且正负之分，不但需要存储他的值，还能区分他的正负号。
float的指数部分占为8bit,能表示0-255的值,指数在写入内存前加127，读取时再减去127，正数负数就显而易见。
即先确定内存中，指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值。这样符号和值全都确认下来了。

精度问题:
对于十进制小数，整数部分通过 不断除以2，直到余数为0。一个有限位数的整数一定能转换为有限位数的二进制。
但是小数就不一定了，小数部分转换为二进制使用"乘2取整法"，不断乘以2，直到小数部分为0。一个有限位数的小数并不一定能转换成有限位数的 二进制。

对于float，尾数部分有23位，再加上一个隐含的整数1，一共是24位。最后一位可能是精确数字，也可能是近似数字； 除此之外剩余的23位一定是精确数字。
从二进制角度看，整体精度在23-24位之间。从十进制的角度来看整体精度是7-8位。
同理 double二进制精度为52-53位，十进制形式的精度为15-16位。
*/


/*
1) 大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。
这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。

2) 小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。
这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。
*/

//浮点数结构体
typedef struct {
    unsigned int nMant : 23;  //尾数部分
    unsigned int nExp : 8;  //指数部分
    unsigned int nSign : 1;  //符号位
} FP_SINGLE;

int main()
{
    char strBin[33] = { 0 };
    /*
    19.625 转换成二进制的指数形式为：19.625 = 1.0011101×2^4
    此时符号为 0；
    尾数为 1.0011101，截掉整数部分后为 0011101，补齐到 23 Bits 后为 001 1101 0000 0000 0000 0000；
    指数为 4，4+127 = 131，131 换算成二进制为 1000 0011。
    综上所述，float 类型的 19.625 在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。
    */
    float f = 19.625;
    FP_SINGLE *p = (FP_SINGLE*)&f;
    
    printf("sign: %X\n", p->nSign); //sign: 0
    printf("exp: %X\n", p->nExp);   //exp: 83
    printf("mant: %X\n", p->nMant); //mant: 1D0000
   
    /**
    *精度损失问题，因为128.101转换为浮点格式后尾数部分过长，被丢掉了，不能被真实的存储。
     128.101 转换成二进制为：
     10000000.0001100111011011001000101101……（无限循环）

     向左移动 7 位后为：
     1.00000000001100111011011001000101101……

     尾数部分为：
     000 0000 0001 1001 1101 1011 001000101101……

     将多出的二进制丢掉后为：
     000 0000 0001 1001 1101 1011

     使用 printf 输出时，还需要进行还原，还原后的二进制为：
     10000000.0001100111011011

     转换成十进制为 128.1009979248046875，按照四舍五入的原则取 6 位小数，就是128.100998。
    */
    
    float a = 128.101;
    printf("a : %f\n", a); //128.100998
    return 0;
}
